"""Single-layer Perceptron model for supervised machine learning.Notes-----    This script is version v0. It provides the base for all subsequent    iterations of the project.Requirements------------    See "requirements.txt""""#%% import libraries and modulesimport numpy as np  import randomimport matplotlib.pyplot as pltimport os#%% figure parametersplt.rcParams['figure.figsize'] = (8,6)plt.rcParams['font.size']= 20plt.rcParams['lines.linewidth'] = 5#%%    class Perceptron:    """Perceptron class."""    def __init__(self, class_size=20, learning_rate=0.01, num_training_epochs=4):        self.class_size = class_size        self.learning_rate = learning_rate        self.num_training_epochs = num_training_epochs        def make_inputs(self):        """Create input patterns."""        np.random.seed(16)        # generate random points for class A        class_a_inputs = np.random.randn(self.class_size, 2) + np.array([0, 3])        # generate random points for class B        class_b_inputs = np.random.randn(self.class_size, 2) + np.array([3, 0])        # concatenate inputs        input_patterns = np.vstack((class_a_inputs, class_b_inputs))        return input_patterns        def make_targets(self):        """Create target patterns."""        # set class A targets to +1        class_a_targets = np.zeros([self.class_size, 1]) + 1        # set class B targets to -1        class_b_targets = np.zeros([self.class_size, 1]) - 1        # concatenate targets        target_patterns = np.vstack((class_a_targets, class_b_targets))        return target_patterns        def signum_function(self, linear_combiner_output):        """Apply signum function as activation function."""        quantized_response = np.sign(linear_combiner_output)        return quantized_response        def initialize_weights(self):        """Initialize weights."""        weights = np.zeros(shape=(1, 2))        return weights            def initialize_bias(self):        """Initialize bias."""        bias = 0        return bias        def train_model(self, input_patterns, target_patterns):        """Train the model parameters to find a linear boundary           that separates the data into different classes."""        # initialize weights        weights = Perceptron().initialize_weights()        # initialize bias        bias = Perceptron().initialize_bias()        # initialize epoch index        epoch_index = 0        while epoch_index < self.num_training_epochs:            print(weights, bias)            # select input_pattern and corresponding target pattern            for input_pattern, target_pattern in zip(input_patterns, target_patterns):                # compute output of linear combiner                linear_combiner_output = np.dot(weights, input_pattern) + bias                # apply signum function                actual_pattern = Perceptron().signum_function(linear_combiner_output)                # compute error                error = target_pattern - actual_pattern                # update weights                weights = weights + self.learning_rate  * error * input_pattern                # update bias                bias = bias + self.learning_rate * error            # increment epoch index            epoch_index += 1                    return weights, bias#%% instantiate Perceptron classmodel = Perceptron()#%% create input and target patternsinput_patterns = model.make_inputs()target_patterns = model.make_targets()#%% train modelweights, bias = model.train_model(input_patterns, target_patterns)#%% make figures"""Ax + By + C = 0   By = -Ax -C   y  = -A/Bx -C/B   slope = -A/B   y_intercept = -C/B   ---------------------   w1x1 + w2x2 + b = 0   w2x2 = -w1x1 -b   x2 = -w1/w2x1 -b/w2   slope = -w1/w2   y_intercept = -b/w2"""x_min = input_patterns[:, 0].min()x_max = input_patterns[:, 0].max()x_data = np.linspace(x_min, x_max, 10)slope = -weights.item(0)/weights.item(1)y_intercept = -bias/weights.item(1)y_data = slope * x_data + y_interceptclass_a = input_patterns[:model.class_size, :]class_b = input_patterns[model.class_size:, :]plt.figure()plt.scatter(class_a[:, 0], class_a[:, 1], s=200, color='red', marker='o', label='class A')plt.scatter(class_b[:, 0], class_b[:, 1], s=200, color='blue', marker='x', label='class B')plt.plot(x_data, y_data, color='k', linestyle='-')plt.xlabel('x')plt.ylabel('y')plt.legend()plt.show()